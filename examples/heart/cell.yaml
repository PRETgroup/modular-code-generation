inputs:
  g: REAL
outputs:
  v: REAL
  resting: BOOLEAN
  stimulated: BOOLEAN
parameters:
  C1:
    type: REAL
    default: -8.7
  C2:
    type: REAL
    default: -190.9
  C3:
    type: REAL
    default: -190.4
  C4:
    type: REAL
    default: -23.6
  C5:
    type: REAL
    default: -45.5
  C6:
    type: REAL
    default: -12.9
  C7:
    type: REAL
    default: 777200
  C8:
    type: REAL
    default: 58900
  C9:
    type: REAL
    default: 276600
  C10:
    type: REAL
    default: -6.9
  C11:
    type: REAL
    default: 75.9
  C12:
    type: REAL
    default: 6826.5
  C13:
    type: REAL
    default: -33.2
  C14:
    type: REAL
    default: 20
  C15:
    type: REAL
    default: 2
  V_O:
    type: REAL
    default: 131.1
  V_T:
    type: REAL
    default: 44.5
  V_R:
    type: REAL
    default: 30
  v_n_R_max:
    type: REAL
    default: 0.04
  autorhythmic_rate:
    type: REAL
    default: 0
locations:
  q0:
    invariant: v < V_T && g < V_T && (pacing_rate <= 0 || t_auto < pacing_rate)
    flow:
      v_x: C1 * v_x
      v_y: C2 * v_y
      v_z: C3 * v_z
      t_auto: 1
    update:
      v: v_x - v_y + v_z
      resting: true
    transitions:
      - to: q1
        guard: pacing_rate > 0 && t_auto >= pacing_rate
        update:
          v_x: V_T * C7 / (C7 - C8 + C9)
          v_y: V_T * C8 / (C7 - C8 + C9)
          v_z: V_T * C9 / (C7 - C8 + C9)
          v: V_T
          theta: 0
          f_theta: f(0)
      - to: q1
        guard: g >= V_T && (pacing_rate <= 0 || t_auto < pacing_rate)
        update:
          v_x: 0.3 * v
          v_y: 0.0 * v
          v_z: 0.7 * v
          theta: v / V_T
          f_theta: f(v / V_T)
  q1:
    invariant: v < V_T && g > 0 && (pacing_rate <= 0 || t_auto < pacing_rate)
    flow:
      v_x: C4 * v_x + C7 * g
      v_y: C5 * v_y + C8 * g
      v_z: C6 * v_z + C9 * g
      t_auto: 1
    update:
      v: v_x - v_y + v_z
    transitions:
      - to: q2
        guard: v == V_T || (pacing_rate > 0 && t_auto >= pacing_rate)
        update:
          t_auto: 0
          resting: false
      - to: q0
        guard: g <= 0 && v < V_T && t_auto < pacing_rate
  q2:
    invariant: v < V_O - 80.1 * sqrt(theta)
    flow:
      v_x: C10 * v_x
      v_y: C11 * v_y
      v_z: C12 * v_z
      t_auto: 1
    update:
      v: v_x - v_y + v_z
      stimulated: true
    transitions:
      - to: q3
        guard: v == V_O - 80.1 * sqrt(theta)
        update:
          stimulated: false
  q3:
    invariant: v > V_R
    flow:
      v_x: C13 * v_x * f_theta
      v_y: C14 * v_y * f_theta
      v_z: C15 * v_z
      t_auto: 1
    update:
      v: v_x - v_y + v_z
    transitions:
      - to: q0
        guard: v == V_R
functions:
  f:
    inputs:
      theta: REAL
    logic: |
      if(theta >= v_n_R_max) {
        return 4.03947
      }

      return 0.29*exp(62.89*theta) + 0.70*exp(-10.99*theta)
  calculate_pacing_rate:
    logic: |
      if(autorhythmic_rate > 0) {
        return 1 / (autorhythmic_rate / 60.0)
      }

      return 0
initialisation:
  state: q0
  valuations:
    pacing_rate: calculate_pacing_rate()
    resting: true
